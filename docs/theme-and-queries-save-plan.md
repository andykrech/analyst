# План сохранения темы и поисковых запросов в БД

Документ описывает, **что** сохраняем, **в каком формате** и **какие поля обязательны**. Код не пишем — только план.

---

## 1. Общий подход

- Сохраняем **содержимое темы**, которое уже формируется на фронте (заголовок, описание, ключевые поля, языки), плюс все обязательные поля модели Theme.
- Поисковые запросы сохраняем в **той же структуре, что на фронте** (SavedQuery с `termIds`); пулы терминов храним в полях темы в формате объектов с id, text, context, translations.

---

## 2. Что сохраняем

### 2.1. Тема (таблица `themes`)

**Из фронта (TopicTheme + пулы из SearchData):**

| Поле в БД   | Источник на фронте        | Формат хранения |
|-------------|---------------------------|------------------|
| title       | theme.title               | строка, обязательное |
| description | theme.description         | строка, обязательное |
| keywords    | search.keywordTerms (пул) | JSONB: массив объектов терминов (см. ниже) |
| must_have   | search.mustTerms (пул)    | JSONB: массив объектов терминов |
| exclude     | search.excludeTerms (пул) | JSONB: массив объектов терминов |
| languages   | theme.languages           | JSONB: массив строк кодов языков, например `["ru", "en"]` |

**Формат одного термина в `keywords` / `must_have` / `exclude`:**

- `id` — строка (UUID с фронта), обязательное для резолва в слое поиска.
- `text` — строка, обязательное.
- `context` — строка, по желанию (по умолчанию `""`).
- `translations` — объект `{ "код_языка": "перевод" }`, по желанию (по умолчанию `{}`).
- Поле `needsTranslation` с фронта при сохранении можно не хранить или хранить для UI; для поиска достаточно id + text (и при необходимости translations).

**Обязательные поля темы, которые должны быть заполнены при сохранении:**

- `user_id` — из текущей сессии/контекста (не с фронта в payload, а на бэкенде).
- `title` — не пустая строка.
- `description` — не пустая строка.
- `keywords` — массив (может быть пустым `[]`).
- `must_have` — массив (может быть пустым `[]`).
- `exclude` — массив (может быть пустым `[]`).
- `languages` — массив (может быть пустым `[]`).
- `update_interval` — строка; если не передаётся, подставлять значение по умолчанию (в модели: `"weekly"`).
- `status` — строка; если не передаётся, по умолчанию `"draft"`.
- `backfill_status` — строка; по умолчанию `"not_started"`.
- `backfill_horizon_months` — число; по умолчанию `12`.

**Опциональные поля темы (можно не передавать или передать null):**

- `region` — строка или null.
- `last_run_at`, `next_run_at` — даты; обычно выставляет планировщик, не фронт при сохранении.

**Служебные (бэкенд выставляет сам при создании/обновлении):**

- `id` — генерируется при создании темы.
- `created_at`, `updated_at` — серверные.
- `deleted_at` — null при создании; при soft-delete заполняется на бэкенде.

---

### 2.2. Поисковые запросы (таблица `theme_search_queries`)

Сохраняем **только сохранённые запросы** (на фронте это слоты 1–3, не черновик). Каждый запрос — одна строка в БД.

**Структура `query_model` в БД — как на фронте (SavedQuery):**

- `keywords`:
  - `groups` — массив групп; каждая группа: `id` (string), `op` (`"OR"` | `"AND"`), `termIds` (массив string).
  - `connectors` — массив `"OR"` | `"AND"`, длина `len(groups) - 1`.
- `must`: `mode` (`"ALL"` | `"ANY"`), `termIds` (массив string).
- `exclude`: `termIds` (массив string).

Все `termIds` ссылаются на `id` терминов из пулов темы (`keywords`, `must_have`, `exclude`). Резолв id → текст выполняется в начале слоя поиска по данным темы.

**Обязательные поля строки запроса:**

- `theme_id` — id темы, к которой привязан запрос.
- `order_index` — порядковый номер запроса в теме (1, 2, 3 при трёх сохранённых).
- `query_model` — объект описанной выше структуры (не пустой; группы могут быть пустыми, termIds — пустые массивы допускаются).

**Опциональные поля строки запроса:**

- `id` — при создании можно генерировать на бэкенде (UUID); при обновлении темы и «перезаписи» запросов можно переиспользовать или создавать новые.
- `title` — строка или null (короткое название для UI).
- `time_window_days` — число или null.
- `target_links` — число или null.
- `enabled_retrievers` — JSONB (массив строк) или null.
- `is_enabled` — булево; по умолчанию `true`.

---

## 3. Обязательность и валидация

### Тема

- Перед сохранением проверять: `title` и `description` не пустые (после trim).
- `keywords`, `must_have`, `exclude` — всегда массивы; элементы с пустым `text` можно отфильтровать или считать ошибкой — зафиксировать в правилах валидации.
- `languages` — массив строк; пустой допустим.
- Остальные обязательные поля из модели Theme задать значениями по умолчанию, если не пришли с клиента.

### Поисковые запросы

- В каждом `query_model` проверять наличие полей `keywords`, `must`, `exclude` и ожидаемой вложенности (groups, termIds, connectors, mode). Все `termIds` должны ссылаться на существующие id в соответствующих пулах темы (keywords / must_have / exclude) — валидация при сохранении по желанию; при построении плана поиска отсутствующий id можно пропускать или считать ошибкой.
- Количество записей на одну тему — по договорённости (например, не более 3, по числу слотов на фронте).

---

## 4. Сценарии сохранения

### 4.1. Создание новой темы

1. Получить с фронта: theme (title, description, languages, пулы в формате терминов с id, text, context, translations) и список сохранённых запросов (1–3 шт.) в формате SavedQuery.
2. Подставить `user_id`, значения по умолчанию для обязательных полей темы.
3. Сохранить тему в `themes` (получить `theme_id`).
4. Для каждого сохранённого запроса вставить строку в `theme_search_queries` с `theme_id`, `order_index` (1, 2, 3), `query_model` в формате с termIds.

### 4.2. Обновление существующей темы

1. Получить с фронта те же данные (тема + сохранённые запросы).
2. Обновить запись в `themes` по id (title, description, keywords, must_have, exclude, languages и при необходимости другие редактируемые поля).
3. Поисковые запросы: стратегия «заменить все» — удалить все строки `theme_search_queries` с данным `theme_id`, вставить заново 1–3 записи с новыми `query_model` и order_index. Либо стратегия «обновить по order_index» — сопоставить по order_index и обновить query_model и остальные поля; недостающие слоты удалить, новые добавить. Выбор стратегии зафиксировать в плане/API.

---

## 5. Итоговая сводка

| Сущность   | Что сохраняем | Формат |
|-----------|----------------|--------|
| Тема      | Заголовок, описание, пулы терминов (ключевые, обязательные, минус), языки + все обязательные поля модели | keywords/must_have/exclude — массивы объектов `{ id, text, context, translations }`; languages — массив строк |
| Запросы   | До 3 сохранённых запросов на тему | query_model — как SavedQuery на фронте: groups[].termIds, must.termIds, exclude.termIds, connectors, must.mode |

Обязательно заполняются: для темы — user_id, title, description, keywords, must_have, exclude, languages и поля с дефолтами (update_interval, status, backfill_status, backfill_horizon_months); для каждого запроса — theme_id, order_index, query_model. Остальное — по контракту API и правилам валидации.
